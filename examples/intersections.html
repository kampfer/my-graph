<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>
<body>
    <script type="module">
        import { d3, math } from '../../dist/graph.js';

        function project(p, p1, p2) {
            const v1 = math.Vector2.fromSubVectors(p, p1);
            const v2 = math.Vector2.fromSubVectors(p2, p1);
            const k = v1.dot(v2) / v2.lengthSq();
            return new math.Vector2().add(p1).add(v2.multiplyScalar(k));
        }

        function getNewBezierPoint(start, c1, end, r, target) {

            const curve = new math.QuadraticBezierCurve(start, c1, end);
            // let count = 0;

            function iter(p) {
                // count++;
                const line = new math.Line(c1, p);
                const circle = new math.Circle(target, r);
                const j1 = math.utils.intersectSegmentAndCircle(line, circle);
                const pj1 = project(j1, start, end);
                const k = pj1.clone().sub(start).length() / start.clone().sub(end).length();
                const p2 = curve.getPoint(k);
                const delta = p2.clone().sub(j1).length();

                if (delta < 5) {
                    return p2;
                } else {
                    return iter(p2);
                }
            }

            return iter(target);

        }

        const width = window.innerWidth;
        const height = window.innerHeight;
        const r = 30;
        const p1 = new math.Vector2(-400, 0);
        const p2 = new math.Vector2(-230, -250);
        const p3 = new math.Vector2(0, 0);

        const curve = new math.QuadraticBezierCurve(p1, p2, p3);

        const rootSelection = d3.create('svg');
        document.body.appendChild(
            rootSelection
                .attr('width', width)
                .attr('height', height)
                .attr('viewBox', [-width/2, -height/2, width, height])
                .node()
        );

        function renderPoint(p, color) {
            const pSelection = rootSelection.append('circle');
            const d3Drag = d3.drag();
            d3Drag.on('drag', (e) => {
                pSelection
                    .attr('cx', e.x)
                    .attr('cy', e.y);
            });
            pSelection.attr('r', 5)
                .attr('fill', color)
                .attr('stroke', 'none')
                .attr('cx', p.x)
                .attr('cy', p.y)
                .call(d3Drag);
        }

        const d3Drag = d3.drag()
            .on('drag', (e, d) => {
                d.x = e.x;
                d.y = e.y;
                render();
            });

        function render() {
            rootSelection.selectAll('path.curve')
                .data([curve])
                .join(
                    enter => enter.append('path')
                        .classed('curve', true)
                        .attr('fill', 'none')
                        .attr('stroke', '#000')
                )
                .attr('d', curve => `M ${curve.v0.x} ${curve.v0.y} Q ${curve.v1.x} ${curve.v1.y} ${curve.v2.x} ${curve.v2.y}`);

            rootSelection.selectAll('circle.circle')
                .data([p3])
                .join(
                    enter => enter.append('circle')
                        .classed('circle', true)
                        .attr('fill', 'none')
                        .attr('stroke', '#000')
                        .attr('r', r)
                )
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);

            const p = getNewBezierPoint(curve.v0, curve.v1, curve.v2, r, curve.v2);

            rootSelection
                .selectAll('circle.point')
                .data([p1, p2, p3, p])
                .join(
                    enter => enter.append('circle')
                        .attr('r', 5)
                        .classed('point', true)
                        .attr('fill', (d, i) => d3.schemeCategory10[i])
                        .attr('stroke', 'none')
                        .call(d3Drag)
                )
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
        }

        const mousePosition = new math.Vector2();
        function render2() {
            rootSelection.selectAll('path.curve')
                .data([curve])
                .join(
                    enter => enter.append('path')
                        .classed('curve', true)
                        .attr('fill', 'none')
                        .attr('stroke', '#000')
                )
                .attr('d', curve => `M ${curve.v0.x} ${curve.v0.y} Q ${curve.v1.x} ${curve.v1.y} ${curve.v2.x} ${curve.v2.y}`);

            rootSelection.selectAll('path.line')
                .data([index - 1, index + 1])
                .join(
                    enter => enter.append('path')
                        .classed('line', true)
                        .attr('fill', 'none')
                        .attr('stroke', '#000')
                )
                .attr('d', d => {
                    if (d < 0) d = 0;
                    if (d > LUT.length - 1) d = LUT.length - 1;
                    return `M ${mousePosition.x} ${mousePosition.y} L ${LUT[d].x} ${LUT[d].y}`;
                });

            rootSelection
                .selectAll('circle.point')
                .data([p1, p2, p3, mousePosition])
                .join(
                    enter => enter.append('circle')
                        .attr('r', 5)
                        .classed('point', true)
                        .attr('fill', (d, i) => d3.schemeCategory10[i])
                        .attr('stroke', 'none')
                        .call(d3Drag)
                )
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
        }

        function findProjectPoint(intervals) {
            let i1 = intervals[0],
                i2 = intervals[intervals.length - 1],
                t1 = LUT[i1].t,
                t2  = LUTp[i2].t,
                step = (t2 - t1) / 5;

            let minDistance = 0;
            let index = 0;

            for(let j = 1; j <= 3; j++) {
                let p = curve.getPoint(t1 + j * step);
                let distance = p.sub(mousePosition).length();
                if (distance < minDistance) {
                    minDistance = distance;
                    index = j;
                }
            }
            
        }

        const LUT = curve.getLUT(20);
        let index = 0;
        rootSelection.on('mousemove', (e) => {
            mousePosition.x = e.x - width / 2;
            mousePosition.y = e.y - height / 2;

            let minDistance = Infinity;
            LUT.forEach((p, i) => {
                const distance = math.Vector2.fromArray([p.x, p.y]).sub(mousePosition).length();
                if (distance < minDistance) {
                    minDistance = distance;
                    index = i;
                }
            });

            p = findProjectPoint(index);

            render2()
        });

        render2();
    </script>
</body>
</html>